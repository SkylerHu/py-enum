from enum import Enum, EnumMeta
from types import DynamicClassAttribute
from typing import Any, Dict, List, Optional, Tuple, Type, TypeVar

__all__ = ["ChoiceEnum"]

T = TypeVar("T")

def _check_value_type(value: Any) -> None: ...

class _ChoiceType:
    def __new__(cls: Type["_ChoiceType"], *args: Any) -> "_ChoiceType": ...
    def __getnewargs__(self) -> Tuple[Any, ...]: ...

class EnumChoiceMeta(EnumMeta):
    def __new__(
        metacls: Type["EnumChoiceMeta"], classname: str, bases: Tuple[Type[Any], ...], classdict: Any, **kwds: Any
    ) -> "EnumChoiceMeta": ...
    def __contains__(cls: Type[T], value: Any) -> bool: ...
    @property
    def names(cls: Type[T]) -> List[str]: ...
    @property
    def values(cls: Type[T]) -> List[Any]: ...
    @property
    def labels(cls: Type[T]) -> List[str]: ...
    @property
    def choices(cls: Type[T]) -> List[Tuple[Any, str]]: ...
    def get_label(cls: Type[T], key: Any) -> Optional[str]: ...
    def get_extra(cls: Type[T], key: Any) -> Optional[Any]: ...
    def to_js_enum(cls: Type[T]) -> List[Dict[str, Any]]: ...

class ChoiceEnum(_ChoiceType, Enum, metaclass=EnumChoiceMeta):
    """ChoiceEnum with proper type annotations for mypy support"""

    def __getnewargs__(self) -> Tuple[Any, ...]: ...
    @DynamicClassAttribute
    def value(self) -> Any: ...
    @DynamicClassAttribute
    def label(self) -> str: ...
    @DynamicClassAttribute
    def extra(self) -> Optional[Any]: ...
    @DynamicClassAttribute
    def option(self) -> Tuple[Any, str]: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
